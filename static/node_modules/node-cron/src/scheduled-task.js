'use strict';

var tzOffset = require('tz-offset');
/**
 * Creates a new scheduled task.
 *
 * @param {Task} task - task to schedule.
 * @param {*} options - task options.
 */


function ScheduledTask(task, options) {
    var _this = this;

    var timezone = options.timezone;
    /**
     * Starts updating the task.
     *
     * @returns {ScheduledTask} instance of this task.
     */

    this.start = function() {
        _this.status = 'scheduled';

        if (_this.task && !_this.tick) {
            _this.tick = setTimeout(_this.task, 1000 - new Date().getMilliseconds() + 1);
        }

        return _this;
    };
    /**
     * Stops updating the task.
     *
     * @returns {ScheduledTask} instance of this task.
     */


    this.stop = function() {
        _this.status = 'stoped';

        if (_this.tick) {
            clearTimeout(_this.tick);
            _this.tick = null;
        }

        return _this;
    };
    /**
     * Returns the current task status.
     *
     * @returns {string} current task status.
     * The return may be:
     * - scheduled: when a task is scheduled and waiting to be executed.
     * - running: the task status while the task is executing. 
     * - stoped: when the task is stoped.
     * - destroyed: whe the task is destroyed, in that status the task cannot be re-started.
     * - failed: a task is maker as failed when the previous execution fails.
     */


    this.getStatus = function() {
        return _this.status;
    };
    /**
     * Destroys the scheduled task.
     */


    this.destroy = function() {
        _this.stop();

        _this.status = 'destroyed';
        _this.task = null;
    };

    task.on('started', function() {
        _this.status = 'running';
    });
    task.on('done', function() {
        _this.status = 'scheduled';
    });
    task.on('failed', function() {
        _this.status = 'failed';
    });

    this.task = function() {
        var date = new Date();

        if (timezone) {
            date = tzOffset.timeAt(date, timezone);
        }

        _this.tick = setTimeout(_this.task, 1000 - date.getMilliseconds() + 1);
        task.update(date);
    };

    this.tick = null;

    if (options.scheduled !== false) {
        this.start();
    }
}

module.exports = ScheduledTask;